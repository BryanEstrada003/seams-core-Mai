#+TITLE: Literate NixOS Build
#+AUTHOR: Rohit Goswami
#+PROPERTY: header-args+ :comments link
#+STARTUP: outline

# Local Variables:
# eval: (add-hook (quote after-save-hook) (lambda nil (org-babel-tangle)) nil t)
# org-babel-use-quick-and-dirty-noweb-expansion: t
# End:

* Rationale
For utilizing cross system builds, ~cmake~ is not good enough. This is
especially true for software like ~supaaYoda~ which is developed on ArchLinux,
which usually has the bleeding edge versions of software.

To this end, for reproducible cross operating system usage, there are only a few
viable options:

- "Fat" Binary :: Basically a binary with all the libraries bundled. This is
     silly and more than slightly wasteful. It is also slow to compile.
- Docker Image :: This is actually a great option and will be provided in the
     future. Caveats include the inherent superuser equivalency for the docker
     group and other affiliated security issues.
- Nix Package :: Though not as easy to set up, this is the route considered by
     this document. Essentially, ~nix~ is better than docker in-so-far as
     non-root users are considered. Though ~nix~ is best installed with root,
     packages can be used without escalating privileges.

** Acknowledgements
Conceptually, this document owes its existence to the excellent work of [[https://github.com/zimbatm][zimbatm]] and
his [[https://github.com/zimbatm/nix-cpp-demo][nix-cpp-demo]] repository. Of course the opportunity to use [[https://www.cs.tufts.edu/~nr/noweb/][noweb]] is also too
good to pass up. Finally, much of the descriptions here are lifted from the [[https://nixos.org/nix/manual/#chap-writing-nix-expressions][nix
manual]].
* Implementation
The rest of this document tangles to the appropriate files for ~nix-shell~
usage. We will be using the [[https://orgmode.org/manual/Noweb-reference-syntax.html#Noweb-reference-syntax][noweb syntax]] where required. Most of the blocks will
be tangled all at once.
** Default driver
For readability purposes, the root of the project will contain a ~default.nix~
which is the entry point for the nix build. As such it is almost blank and
simply initializes the subsequent calls.
#+BEGIN_SRC nix :tangle no
{ pkgs ? import <nixpkgs> {}, }:
rec {
  myProject = pkgs.stdenv.mkDerivation {
    name = "upaaYoda";
    version = "dev-0.1";
    buildInputs = with pkgs; [
      (callPackage ./nix/catch.nix { })
    ];
  };
}
#+END_SRC
** Nix Source
Here we shall delegate the remainder of the code to a subdirectory. This is a
readability measure which is rather redundant.
We can define a usage header here as well. This is taken from [[https://gist.github.com/daniel-j-h/9a899c1a9fbe5d867f289aba2fcc47e4][this gist]].
#+NAME: headerComment
#+BEGIN_SRC nix :tangle no
# Nix skeleton for compiler, cmake, boost.
# Dependencies (boost and the rest) are built with selected compiler (for ABI compatibility).
# Examples:
#   nix-shell --argstr compiler gcc5 --run 'mkdir build && cd build && cmake .. && cmake --build .'
#   nix-shell --argstr compiler gcc6 --run 'mkdir build && cd build && cmake .. && cmake --build .'
#   nix-shell --argstr compiler clang_38 --run 'mkdir build && cd build && cmake .. && cmake --build .'
#+END_SRC
Our program expression will first be defined as a function.
#+NAME: basicFunctions
#+BEGIN_SRC nix :noweb yes
{ nixpkgs ? import <nixpkgs> {}, <<nixArgs>> }:
#+END_SRC
*** Nix Arguments
We can define arguments which may be passed on the command line.
#+NAME: nixArgs
#+BEGIN_SRC nix :tangle no
compiler ? "clang"
#+END_SRC
We will also determine the appropriate set of packages needed to compile our
~supaaYoda~. Since we have no *runtime dependencies* we don't need any *build
inputs*. So here we stick to setting the *build-time dependencies* via ~nativeBuildInputs~.
#+NAME: runtimeDeps
#+BEGIN_SRC nix :tangle no
nixpkgs.boost nixpkgs.lua nixpkgs.cmake nixpkgs.luarocks nixpkgs.blas nixpkgs.conan
#+END_SRC
*** Nix Variables
Now that we have the basic function form, let us set the variables.
#+NAME: nixVars
#+BEGIN_SRC nix :tangle no
stdenv = nixpkgs.overrideCC nixpkgs.stdenv nixpkgs.${compiler};
#+END_SRC
*** Overlay Specification
We can use our own ~nix~ builders with an overlay.
#+NAME: overlay
#+BEGIN_SRC nix :tangle no
overlay = self: pkgs: with nixpkgs; {
        luafilesystem = callPackage ./nix/luafilesystem.nix
        }
#+END_SRC
*** Nix Meta
We define project specific meta variables here.
#+NAME: nixMeta
#+BEGIN_SRC nix :tangle no :noweb yes
  myProject = stdenv.mkDerivation {
    name = "supaaYoda";
    version = "dev-0.1";
    nativeBuildInputs = [ <<runtimeDeps>> ];
    buildInputs = [  ];
};
#+END_SRC
** Putting Things Together
At this point we can now put everything together and tangle the output.

#+NAME: finalNix
#+BEGIN_SRC nix :tangle default.nix :noweb yes
<<headerComment>>
<<basicFunctions>>
let
  <<nixVars>>
  in rec {
  <<nixMeta>>
  }
#+END_SRC

Additionally this will simply do nothing without a ~default.nix~ so we will
create one in the ~nix/src~ folder as well.

#+NAME: supaaDefault
#+BEGIN_SRC nix :tangle no
{ pkgs ? import <nixpkgs> {}, }:
rec {
  myProject = pkgs.stdenv.mkDerivation {
    name = "supaaYoda";
    version = "dev-0.1";
    buildInputs = with pkgs; [
      (callPackage ./catch.nix { })
    ];
  };
}
#+END_SRC

Although this is not required here, we will use the latest ~catch2~ (from [[https://blog.galowicz.de/2018/02/27/managing_libraries_with_nix/][here]]).

#+BEGIN_SRC nix :tangle nix/catch.nix
{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = "catch-${version}";
  version = "2.1.2";

  src = fetchurl {
      url = "https://github.com/catchorg/Catch2/releases/download/v2.1.2/catch.hpp";
      sha256 = "e8b8f3109716891aa99b1a8e29cd0d627419bdc4a8d2eeef0d8370aaf8d5e483";
  };

  # It is just the file. No unpacking needed. Seems like we need to create
  # _some_ folder, otherwise we get errors.
  unpackCmd = "mkdir dummy_dir";

  installPhase = ''
    mkdir -p $out/include/catch
    cp ${src} $out/include/catch/catch.hpp
  '';

  meta = {
    description = "A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later";
    homepage = http://catch-lib.net;
  };
}
#+END_SRC

We will need a paticular ~luarocks~ package, so we will build that:

#+NAME: luafilesystem
#+BEGIN_SRC nix :tangle nix/luafilesystem.nix
fileSystem = buildLuaPackage {
  name = "filesystem-1.6.2";
  src = fetchurl {
    url = "https://github.com/keplerproject/luafilesystem/archive/v1_6_2.tar.gz";
    sha256 = "1n8qdwa20ypbrny99vhkmx8q04zd2jjycdb5196xdhgvqzk10abz";
  };
  meta = {
    homepage = "https://github.com/keplerproject/luafilesystem";
    hydraPlatforms = stdenv.lib.platforms.linux;
    maintainers = with maintainers; [ flosse ];
  };
};
#+END_SRC
