#+TITLE: Literate NixOS Build
#+AUTHOR: Rohit Goswami
#+PROPERTY: header-args+ :comments link
#+STARTUP: outline

* Rationale
For utilizing cross system builds, ~cmake~ is not good enough. This is
especially true for software like ~supaaYoda~ which is developed on ArchLinux,
which usually has the bleeding edge versions of software.

To this end, for reproducible cross operating system usage, there are only a few
viable options:

- "Fat" Binary :: Basically a binary with all the libraries bundled. This is
     silly and more than slightly wasteful. It is also slow to compile.
- Docker Image :: This is actually a great option and will be provided in the
     future. Caveats include the inherent superuser equivalency for the docker
     group and other affiliated security issues.
- Nix Package :: Though not as easy to set up, this is the route considered by
     this document. Essentially, ~nix~ is better than docker in-so-far as
     non-root users are considered. Though ~nix~ is best installed with root,
     packages can be used without escalating privileges.

** Acknowledgements
Conceptually, this document owes its existence to the excellent work of [[https://github.com/zimbatm][zimbatm]] and
his [[https://github.com/zimbatm/nix-cpp-demo][nix-cpp-demo]] repository. Of course the opportunity to use [[https://www.cs.tufts.edu/~nr/noweb/][noweb]] is also too
good to pass up. Finally, much of the descriptions here are lifted from the [[https://nixos.org/nix/manual/#chap-writing-nix-expressions][nix manual]].

The best introduction to nix and a bunch of functional concepts is the [[https://nixos.org/nixos/nix-pills][nix-pills]]
set of articles. Additionally the utility of ~--pure~ along with a simple set of
examples is provided in this [[https://blog.galowicz.de/2018/02/27/managing_libraries_with_nix/][blog post by Jacek]]. For an alternate approach to
using ~nix~, this [[https://matthewbauer.us/blog/nix-and-org.html][blog post by Matthew Bauer]] is an excellent read.
* Implementation
The rest of this document tangles to the appropriate files for ~nix-shell~
usage. We will be using the [[https://orgmode.org/manual/Noweb-reference-syntax.html#Noweb-reference-syntax][noweb syntax]] where required. Most of the blocks will
be tangled all at once.

#+BEGIN_NOTES
Due to the fact that ~nix-shell~ respects the system ~.bashrc~, we will not be
able to obtain a ~nix~ shell directly as the ~$PATH~ variable will be overwritten.
#+END_NOTES

We will use the ~run~ command to spawn a shell in a non-interactive shell (as
opposed to ~command~ which spawns an interactive shell) so as to not source the
local ~.bashrc~

#+BEGIN_SRC bash
nix-shell --run bash
#+END_SRC

** Project Root
Every invocation of ~nix-shell~ looks for a ~shell.nix~ file, failing which a
~default.nix~ is required. To this end, we will generate a dummy file which
essentially passes control to a ~yodaStruct.nix~ file which may also be built
directly with ~nix-build~.

We will note that this file simply:
- defines a variable which is passed to ~yodaStruct.nix~
- where said variable imports all relevant ~nix~ files in a subfolder
#+BEGIN_SRC nix :tangle default.nix
  # Define
  let
  # Import
    buildpkgs = import ./nix {};
  in
  # Pass to
  buildpkgs.yodaStruct
#+END_SRC

** Project Source
Although we will be using a file which is meant to build the project,
~nix-shell~ will still seek a ~default.nix~ in the subfolder, so we shall assert
that the form of this is as shown.

#+BEGIN_SRC nix :tangle nix/default.nix :noweb yes
# something ? default value ---- Variable declration
# pattern : body ---- Function prototype
{ nixpkgs ? import ./nixpkgs }:
  # Define
  let overlay = self: pkgs: with buildpkgs {
  # All the other nix files
  <<overlayFiles>>
  }; in
  # Ensure reproducibility
  nixpkgs {
  config = {};
  overlays = [overlay];
  }
#+END_SRC

Essentially we note that we are simply asserting that ~nixpkgs~ will be called
with the variables defined in the ~overlayFiles~ block.
*** Nix Libraries
Every ~noweb~ expansion block under ~overlayFiles~ is essentially the expression
defining a particular library or helper variable. To clarify matters, they are
defined and extended where their constituents are explained.
** Nix Sources
At this stage we will now move towards creating application logic, along with
it's requisite libraries.
*** Catch2
This is actually handled by ~conan~, and is adapted from [[https://blog.galowicz.de/2018/02/27/managing_libraries_with_nix/][Jacek's blog]]. It is
remarkably trivial to mantain static versions of things with ~nix~ though, so it
is still useful.
#+BEGIN_SRC nix :tangle nix/catch2.nix
{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = "catch-${version}";
  version = "2.5.0";

  src = fetchurl {
      url = "https://github.com/catchorg/Catch2/releases/download/v2.5.0/catch.hpp";
      sha256 = "a87d5c0417aaf1c3d16565244a1b643e1999d5838d842823731bc18560268f94";
  };

  # This is a header only library. No unpacking needed. Seems like we need to create
  # _some_ folder, otherwise we get errors.
  unpackCmd = "mkdir fake_dir";

  installPhase = ''
    mkdir -p $out/include/catch
    cp ${src} $out/include/catch/catch.hpp
  '';

  meta = {
    description = "A modern, C++-native, header-only, test framework for unit-tests, TDD and BDD - using C++11, C++14, C++17 and later";
    homepage = http://catch-lib.net;
  };
}
#+END_SRC
**** Calling the expression
For the actual variable definition which will use ~callPackage~ to evaluate the
expression defined in the tangled block above, we have:
#+NAME: catch2
#+BEGIN_SRC nix :tangle no
catch2 = callPackage ./catch2.nix {};
#+END_SRC
As discussed previously, this is now added to the ~noweb~ block to be tangled
into the output file.
#+NAME: overlayFiles
#+BEGIN_SRC nix :tangle no :noweb yes
# Package for testing
  <<catch2>>
#+END_SRC

** yodaStruct Overlay
The main program is also defined and used in the same way as the libraries, so:
#+NAME: yodaStruct
#+BEGIN_SRC nix :tangle no
yodaStruct = callPackage ./yodaStruct.nix {};
#+END_SRC
Into the overlay:
#+NAME: overlayFiles
#+BEGIN_SRC nix :tangle no :noweb yes
# Program expression
  <<yodaStruct>>
#+END_SRC
*** Expression
The expression for building the program is conceptually a simple extension of
the ~default.nix~ process, we declare a function which has a variety of inputs,
either defined in the standard packages or locally, and then we simply declare a
build script of sorts.

#+BEGIN_NOTES
It is only at this stage will we note the concept of *runtime dependencies* as
defined in ~buildInputs~ and the *build dependencies* as defined by ~nativeBuildInputs~.
#+END_NOTES

We are in a position to leverage the project ~README.md~ to ascertain the build
requirements, and writing out the structure of the project will aid in
determining the libraries to be built or overriden.
#+BEGIN_SRC nix :tangle nix/yodaStruct.nix :noweb yes
# Using patterns, and white space negligence
{ customEnv
, <<yS_inputs>> }
  customEnv.mkDerivation {
  name = "yodaStruct";
  src = lib.cleanSource .././;
  nativeBuildInputs = [
  <<yS_buildDeps>>
  ];
  buildInputs = [
  <<yS_runDeps>>
  ];
  }
#+END_SRC
Where we have leveraged the rather strange design choice of ~noweb~ [[https://orgmode.org/manual/noweb.html][honoring
prefix characters]] for generating sane inputs.

*** Inputs
Very quickly we shall enumerate the reuired inputs as per the ~README~.
#+NAME: yS_inputs
#+BEGIN_SRC nix :tangle no
lib
boost
cmake
#+END_SRC

# Local Variables:
# eval: (add-hook (quote after-save-hook) (lambda nil (org-babel-tangle)) nil t)
# org-babel-use-quick-and-dirty-noweb-expansion: t
# End:
